import random

import matplotlib.pyplot as plt
import networkx as nx
import numpy as np


class Red():

    def __init__(self, NNODOS, inicial, meta,  seed=None, ratio_riesgo=0.25):

        # guardamos el número de nodos 
        self.NNODOS = NNODOS

        # definimos la lista de acciones (puramente informativo de momento, no se utiliza)
        self.acciones = list(range(0, self.NNODOS+1))

        # generamos el grafo
        self.grafo = nx.random_internet_as_graph(self.NNODOS, seed)

       # seleccionamos al azar un porcentaje de los nodos como nodos de alto riesgo, y a la vez
       # guardamos que ninguno está infectado
        dict_riesgos = {}
        dict_infectados = {}
        for i in range(self.NNODOS):
            dict_infectados[i] = {"infectado" : False}
            if random.random() < ratio_riesgo:
                dict_riesgos[i] = {"riesgo" : 10}
            else:
                dict_riesgos[i] = {"riesgo" : 1}

        nx.set_node_attributes(self.grafo, dict_riesgos)
        nx.set_node_attributes(self.grafo, dict_infectados)
        
        #definimos el estado inicial (lo guardamos aparte también para poder resetear el entorno) y la meta
        self.inicial = inicial
        self.estado = inicial
        self.meta = meta

        # definimos un tiempo límite para llegar al objetivo
        self.tiempo_limite = 1000
        
    #método que se ejecuta cada vez que se aplica una acción
    def step(self, accion):

        # Pasa 1 segundo en el reloj
        self.tiempo_limite -= 1 
        
        # Calculamos la recompensa
        recompensa = self.obtener_recompensa(self.estado, accion)
        
        # si la acción es infectar (la definimos como NNODOS, es decir, un número que no corresponde a un nodo), infectamos
        if accion == self.NNODOS:
            self.grafo.nodes[self.estado]['infectado'] = True
        # si no, omprobamos que existe la conexión y cambiamos el estado
        elif self.grafo.has_edge(self.estado, accion):
            self.estado = accion
        
        # Comprobamos que no se haya llegado al final del episodio
        if ( self.tiempo_limite <= 0 or
            (self.estado == self.meta and self.grafo.nodes[self.estado]['infectado'] == True) ): 
            finalizado = True
        else:
            finalizado = False
        
        # Devolvemos los datos
        return self.estado, recompensa, finalizado,
    
    
    #método que se ejecuta para probar la aplicación de una acción sobre un estado
    def step_prueba(self, estado, accion):

        # Calculamos la recompensa
        recompensa = self.obtener_recompensa(estado, accion)

        # actualizamos el estado en el que se quedaría el agente al realizar la acción
        if accion != self.NNODOS and self.grafo.has_edge(estado, accion):
            estado = accion
        
        # Devolvemos los datos
        return estado, recompensa

    
    # Método que obtiene la recompensa de una acción
    # 
    # Parámetros:
    #  - actual: estado actual
    #  - siguiente: acción a realizar (número de nodo a moverse o NNODOS para infectar)
    # Return: la recompensa de dicha acción partiendo de dicho estado
    def obtener_recompensa(self, actual, siguiente):

        # si se está infectando al nodo actual
        if(siguiente == self.NNODOS):
            # si el nodo actual es el objetivo, devuelve la máxima recompensa
            if(actual == self.meta):
                return 999
            # en caso contrario, penaliza la acción
            return -5

        # si se mantiene en el estado actual
        if(actual == siguiente):
            # si está en el estado objetivo, devuelve la máxima recompensa
            if(actual == self.meta and self.grafo.nodes[actual]['infectado'] == True):
                return 999
            # en caso contrario, penalización de -1 al haber pasado el tiempo
            return -1
        
        # si se mueve por una conexión válida
        if( self.grafo.has_edge(actual, siguiente) ):
            # si el destino aporta poca información, se penaliza ligeramente
            if(self.grafo.degree(siguiente)==1):
                return -3
            # en caso contrario, devolvemos el riesgo del nodo (el riesgo mínimo 
            # será 1, equivalente a la penalización por tiempo)
            return - self.grafo.nodes[actual]["riesgo"]

        # si no es ninguno de los casos anteriores, penalización máxima al ser un movimiento imposible.
        return -111
    
    # Método que obtiene los estados a los que se puede llegar desde el estado actual
    # 
    # Parámetros:
    #  - actual: el estado actual
    # Return:
    #  - acciones: las acciones posibles desde ese estado
    def get_posibles_acciones(self, actual):

        # incluimos los nodos a los que puede llegar desde el actual
        acciones = [a for a in self.grafo[actual]]
        # si es un estado no infectado, añadimos la acción de infectarlo
        if self.grafo.nodes[actual]['infectado'] == False: acciones.append(self.NNODOS)

        return acciones

    def get_infectado(self, estado):
        return self.grafo.nodes[estado]['infectado']

    # en este método se programaría la visualización del entorno, cosa que no haremos 
    # de momento. En un futuro debería mostrar, al menos, una imagen con el grafo, y 
    # algún indicador con la posición actual, el camino seguido, y los nodos infectados
    def render(self):
        pass
    
    
    def reset(self):
        # Reiniciamos las variables a sus valores iniciales
        self.estado = self.inicial
        
        dict_infectados = {}
        for i in range(self.NNODOS):
            dict_infectados[i] = {"infectado" : False}
        nx.set_node_attributes(self.grafo, dict_infectados)

        self.tiempo_limite = 1000
        return self.estado
